Copyright    Massachusetts Institute of Technology    1985

This note describes protocol version ten of window system X.

Changes from release 3 of X:
	X_StippleFill
	X_QueryWindow has added input mask returned.


The X protocol can be built on top of any reliable byte stream.  A simple block
protocol is used on top of the stream layer.  Most requests are 24 byte blocks;
some carry additional data.  Requests do not have a corresponding reply unless
data is actually expected in return.  This means that error responses in
general will not be caught at the failing request, but rather at some later
request which expects a reply.

On a given machine, displays are numbered from zero.

For TCP connections, display N is associated with port 5800+N ('X' = 0x58) and
with port 5900+N.  That is, the X server listens and accepts new connections on
these ports.  The X server expects connections made on the 58xx port to come
from hosts transmitting data in little Indian (VAX order), and expects
connections made on the 59xx port to come from hosts transmitting data in big
Indian (68000 order).  For connections with opposite-order machines, the server
will byte swap all 16-bit and 32-bit quantities in all requests and replies,
with the exception of host addresses, which should be transmitted in standard
network order.  In this way, clients need never byte-swap, and byte-swapping
need not occur between hosts with the same byte ordering.

For Unix-domain connections, display number ? associated with path /dev/X?.

For DECnet connections, display ? is associated with object name "X?".

The coordinate system has X horizontal and Y vertical, and is in terms of
pixels.  The point (0, 0) is the upper left.  Coordinates within a window are
always specified in terms of the inside of a window (not including the
borders).  A pixel is an N-bit value, where N is the number of bit planes
provided by the particular display; a pixel value indexes a color map to derive
an actual color to be displayed.

Some C type definitions used below:

	typedef long Window;
	typedef long Font;
	typedef long Bitmap;
	typedef long Pixmap;
	typedef long Cursor;
	typedef long Locator;

For the convenience of certain programming languages, Window, Font, Bitmap,
Pixmap, and Cursor values are guaranteed to have the top three bits all zero.

A Bitmap is a single plane (bit) rectangle.  A Pixmap is an N-plane (pixel)
rectangle, where N is the number of planes provided by the particular display.
In this protocol, N ranges from 1 to 16.  Cursors are used as mouse pointers; a
cursor is an arbitrary two-color shape with an arbitrary "point".  A Locator is
an absolute point on the display, represented as <x,,y> with the X-coordinate
in the high 16 bits and the Y-coordinate in the low 16 bits.

A Bitmap is represented by ((width + 15) / 16) * height * 2 bytes of data.  The
bits are in scanline order, with each scanline padded if necessary to a
multiple of 16 bits.  The pad bits are of arbitrary value.  Within a scanline,
the bits are represented left to right, stored in 16-bit words, but the bits
are reversed within a given 16-bit word: the leftmost bit of the scanline is
the least significant bit of the word.

A Pixmap can be represented in either "XY-format" or "Z-format".  In XY-format,
each plane is represented as a Bitmap, and the planes appear from most to least
significant bit order.  The total number of bytes is thus
((width + 15) / 16) * height * 2 * depth.  In Z-format, the pixels are in
scanline order, left to right within a scanline.  For displays with 2 to 8
planes, each pixel is represented by a single byte; the total number of bytes
is thus width * height.  For displays with 9 to 16 planes, each pixel is
represented by a 16-bit word; the total number of bytes is thus
2 * width * height.  Z-format cannot be used on monochrome displays.

Pixel values 0 and 1 are always defined on every display.  They are primarily
intended for use in monochrome applications.  On monochrome displays, pixel
value 0 is black and pixel value 1 is white.  On color displays, the colors may
be redefined by the user.

Display function codes used in all output requests, and their affect on the
destination as a function of the source and the destination (NOT binds
tightest) are:

	GXclear			0x0		0
	GXand			0x1		src AND dst
	GXandReverse		0x2		src AND NOT dst
	GXcopy			0x3		src
	GXandInverted		0x4		NOT src AND dst
	GXnoop			0x5		dst
	GXxor			0x6		src XOR dst
	GXor			0x7		src OR dst
	GXnor			0x8		NOT src AND NOT dst
	GXequiv			0x9		NOT src XOR dst
	GXinvert		0xa		NOT dst
	GXorReverse		0xb		src OR NOT dst
	GXcopyInverted		0xc		NOT src
	GXorInverted		0xd		NOT src OR dst
	GXnand			0xe		NOT src OR NOT dst
	GXset			0xf		1

Given a source and destination pixel, a display function is computed bitwise on
corresponding bits of the pixels.  That is, a boolean operation is performed on
each bit plane of the display.  A "plane mask" can be used to restrict output
operations to a subset of planes; the mask contains a one bit for each pixel
bit (plane) that should be affected.

The C definition of a request looks like:

	typedef struct _XReq {
		unsigned char code;
		unsigned char func;
		unsigned short mask;
		Window windowId;
		union {
		    long l[4];
		    short s[8];
		    unsigned short u[8];
		    char b[16];
		} param;
	} XReq;

Note: requests carrying more than 128K bytes of additional data will cause the
server to close the client's connection.

Input events (keyboard, mouse button, mouse motion, window change) are
generated asynchronously by X and are reported on the same network connection.
Clients must therefore expect any number of input events between any two
replies to requests.  Data coming from X is bundled into 24 byte blocks, with a
code indicating the type of data.  The C definition of this structure is:

	typedef struct _XRep {
		long code;
		union {
		    long l[5];
		    short s[10];
		    unsigned short u[10];
		    char b[20];
		} param;
	} XRep;

The possible XRep codes are:

	X_Reply		0		Normal reply
	X_Error		-1		Error
	else				Asynchronous input event

The contents of event structures are discussed later.  The contents of X_Reply
structures vary with each request, and are documented for each such request.
The contents of an X_Error structure is as follows:

	code		X_Error
	param.l[0]	number of failing request
	param.b[4]	error code
	param.b[5]	original request code
	param.b[6]	original request func
	param.l[2]	original request windowId

Requests are counted per network connection, starting from one.  The possible
error codes are:

	BadRequest	1		bad request code
	BadValue	2		int parameter out of range
	BadWindow	3		parameter not a Window
	BadPixmap	4		parameter not a Pixmap
	BadBitmap	5		parameter not a Bitmap
	BadCursor	6		parameter not a Cursor
	BadFont		7		parameter not a Font
	BadMatch	8		parameter mismatch
	BadTile		9		Pixmap shape invalid for tiling
	BadGrab		10		mouse/button already grabbed
	BadAccess	11		access control violation
	BadAlloc	12		insufficient resources
	BadColor	13		no such color

Not all displays support all variations of all output requests.  Output
requests may be transformed arbitrarily (including being ignored), without
errors being generated.

Some displays have very limited memory for storage of off-screen resources such
as bitmaps, pixmaps, and fonts.

All requests and replies are padded as necessary to be a multiple of four bytes
long.  The pad bytes are of arbitrary value.

The requests are:

X_CreateWindow
	code		1
	func		border width
	windowId	parent Window
	param.s[0]	inside height (not including borders) (> 0)
	param.s[1]	inside width (not including borders) (> 0)
	param.s[2]	outer left coord (start of border)
	param.s[3]	outer top coord (start of border)
	param.l[2]	border tile Pixmap or 0
	param.l[3]	background tile Pixmap or 0

	Creates an unmapped (not displayed) opaque window.  Coordinates are
	relative to the inside of the parent.  A border pixmap need not be
	given if the border width is zero.  If no background pixmap is given,
	the parent's background pixmap is used.  The tilemode of the new window
	is TileModeAbsolute.  The clipmode of the new window is
	ClipModeClipped.  The window does not have a defined cursor.

	The parent window must be an opaque window.

	A window will always be wholly contained within its parent, i.e. any
	parts of the window that extend outside the parent window will not be
	displayed.

	The background and border pixmaps may be freed immediately if no
	further explicit references to them are to be made.

	The reply:

	param.l[0]	Window

	Errors: BadWindow, BadValue, BadPixmap, BadTile, BadMatch

X_CreateTransparency
	code		2
	windowId	parent Window
	param.s[0]	inside height (> 0)
	param.s[1]	inside width (> 0)
	param.s[2]	outer left coord
	param.s[3]	outer top coord

	Creates an unmapped (not displayed) transparent window.  Coordinates
	are relative to the inside of the parent.  The tilemode of the new
	window is TileModeRelative.  The clipmode of the new window is
	ClipModeClipped.  The window does not have a defined cursor.

	The reply:

	param.l[0]	Window

	Errors: BadWindow, BadValue

X_DestroyWindow
	code		3
	windowId	Window

	Unmaps and destroys the window and all of its subwindows.  The windows
	should never again be referenced.

	Windows are automatically destroyed when the creating process closes
	its network connection.

	If the window has a mapped icon window, that icon window is unmapped
	and receives an UnmapWindow event.  If the window is a mapped icon
	window, its corresponding "regular" window is mapped.

	Generates exposure events on formerly obscured opaque windows.

	Errors: BadWindow

X_DestroySubwindows
	code		4
	windowId	Window

	Destroy all subwindows of this window.  The windows should never again
	be referenced.

	Generates exposure events on formerly obscured opaque windows.

	Errors: BadWindow

X_MapWindow
	code		5
	windowId	Window

	Maps and raises the window and displays the window and all of its
	subwindows which have had map requests.  The previous contents of all
	opaque windows are lost; mapping transparent windows does not affect
	the screen.

	Mapping a window when one of its ancestors is unmapped does not cause
	the window to be displayed.

	Has no effect if the window is already mapped.

	Generates an ExposeWindow event on each newly displayed opaque window.

	Errors: BadWindow

X_MapSubwindows
	code		6
	windowId	Window

	Maps all subwindows of the given window in an unspecified order.

	Generates an ExposeWindow event on each newly displayed opaque window.

	Errors: BadWindow

X_UnmapWindow
	code		7
	windowId	Window

	Unmaps the window and all of its subwindows.  Unmapping transparent
	windows does not affect the screen.

	Generates an UnMapWindow event on the window if it is mapped; generates
	exposure events on formerly obscured opaque windows.

	Errors: BadWindow

X_UnmapSubwindows
	code		8
	windowId	Window

	Unmaps all subwindows of the given window.

	Generates an UnMapWindow event on each mapped subwindow; generates
	exposure events on formerly obscured opaque windows.

X_UnmapTransparent
	code		9
	windowId	Window

	Unmaps the window and all of its subwindows, but does not affect the
	screen, even if the window is opaque, and does not generate any
	exposure (or unmap) events.

	Errors: BadWindow

X_RaiseWindow
	code		10
	windowId	Window

	Raise this window above all sibling windows, so that no sibling
	obscures it.

	Raising a transparent window does not affect the screen.  Transparent
	windows never obscure other windows for the purposes of output, but do
	obscure for the purposes of cursor and input control.

	Window hierarchies never interleave.  If window A is obscured by window
	B, then window A will only obscure ancestors of B that are also
	ancestors of A.

	Generates exposure events on formerly obscured opaque windows.

	Errors: BadWindow

X_LowerWindow
	code		11
	windowId	Window

	Lower this window below all sibling windows, so that it doesn't obscure
	any siblings.

	Raising a transparent window does not affect the screen.

	Generates exposure events on formerly obscured opaque windows.

	Errors: BadWindow

X_CircWindowUp
	code		12
	windowId	Window

	Raise the lowest mapped child of this window that is (partially)
	obscured by another child.  Repeated executions lead to round robin
	raising.

	Generates exposure events on formerly obscured opaque windows.

	Errors: BadWindow

X_MoveWindow
	code		13
	func		0 (for future expansion)
	windowId	Window
	param.s[0]	outer left coord (start of border)
	param.s[1]	outer top coord (start of border)

	Moves and raises the window, without changing its size.  Coordinates
	are relative to the inside of the parent.

	The contents of an opaque window are lost if its tilemode is relative
	or if the window is obscured by non-children.  Moving a transparent
	window does not affect the screen.

	Generates an ExposeWindow event on the (opaque) window if its contents
	are lost; generates exposure events on formerly obscured opaque
	windows.

	Errors: BadWindow

X_ChangeWindow
	code		14
	func		0 (for future expansion)
	windowId	Window
	param.s[0]	inside height (not including borders) (> 0)
	param.s[1]	inside width (not including borders) (> 0)

	Changes the size of the window and raises it, without changing its
	upper left hand coordinate.  The contents of an opaque window are lost;
	changing a transparent window does not affect the screen.

	Generates an ExposeWindow event on the (opaque) window; generates
	exposure events on formerly obscured opaque windows.

	Errors: BadWindow, BadValue

X_ConfigureWindow
	code		15
	func		0 (for future expansion)
	windowId	Window
	param.s[0]	inside height (not including borders) (> 0)
	param.s[1]	inside width (not including borders) (> 0)
	param.s[2]	outer left coord (start of border)
	param.s[3]	outer top coord (start of border)

	Changes the size and placement of the window and raises it.  The
	contents of an opaque window are lost; configuring a transparent window
	does not affect the screen.

	Generates an ExposeWindow event on the (opaque) window; generates
	exposure events on formerly obscured opaque windows.

	Errors: BadWindow, BadValue

X_ChangeBackground
	code		16
	windowId	Window
	param.l[0]	background tile Pixmap or 0

	Change the background tile of a window.  If no background pixmap is
	specified, the background pixmap of the window's parent is used (on
	the root window the default background is restored).

	Does not change the current contents of the window.

	Can only be performed on an opaque window.

	The pixmap can be freed immediately if no further explicit references
	to it are to be made.

	Errors: BadWindow, BadMatch, BadPixmap, BadTile

X_ChangeBorder
	code		17
	windowId	Window
	param.l[0]	border tile Pixmap

	Change the border tile of a window and repaint the border.

	Can only be performed on an opaque window that has a border.

	The pixmap can be freed immediately if no further explicit references
	to it are to be made.

	Errors: BadWindow, BadMatch, BadPixmap, BadTile

X_TileMode
	code		18
	func		0: TileModeAbsolute
			1: TileModeRelative
	windowId	Window

	Sets the tilemode of the window.  With TileModeAbsolute (the normal
	case for opaque windows), tiles are laid out with the upper left corner
	of the window as an effective origin.  With TileModeRelative (the
	normal case for transparent windows), tiles are laid out with the upper
	left corner of the closest parent window with an absolute tilemode as
	an effective origin.  The tilemode affects painting of the background
	for exposures and for X_Clear, as well as the X_TileFill and
	X_DrawFilled requests.

	Does not change the current contents of the window.

	Errors: BadWindow, BadValue

X_ClipMode
	code		19
	func		0: ClipModeClipped
			1: ClipModeDrawThru
	windowId	Window

	Sets the clipmode of the window.  With ClipModeClipped (the normal
	case), future output to the window will be obscured by subwindows.
	With ClipModeDrawThru, future output to the window will ignore
	subwindows and draw into them.  In draw-thru mode, the most useful
	display functions are GXxor and GXinvert, so that displaying again will
	erase what was displayed.  Draw-thru mode is useful for drawing window
	outlines when moving or resizing windows.

	The root window starts with ClipModeDrawThru.

	Errors: BadWindow, BadValue

X_QueryWindow
	code		20
	windowId	Window

	Get facts about the window.

	The reply:

	param.s[0]	inside height (not including borders)
	param.s[1]	inside width (not including borders)
	param.s[2]	outer left (start of border)
	param.s[3]	outer right (start of border)
	param.s[4]	border width
	param.b[10]	0: IsUnmapped
			1: IsMapped
			2: IsInvisible (mapped but some ancestor is unmapped)
	param.b[11]	0: IsTransparent
			1: IsOpaque
			2: IsIcon
	param.l[3]	icon Window or opaque Window or 0
	param.l[4]	event mask (see X_SelectInput)

	If windowId is a transparent window, param.b[11] will be IsTransparent
	and param.l[3] will be 0.  If windowId is a normal opaque window,
	param.b[11] will be IsOpaque and param.l[3] will contain the window's
	icon window, if one has been defined with an X_SetIconWindow request.
	If windowId is an icon window, param.b[11] will be IsIcon and
	param.l[3] will contain the icon's corresponding "regular" window.

	Errors: BadWindow

X_StoreName
	code		21
	windowId	Window
	param.s[0]	length of name in characters (>= 0)

	Assigns a name to a window.  This request must be followed by the
	characters of the window name, followed by 0 t0 3 pad bytes to make
	the length a multiple of four.

	The name is typically used by a window manager (to create named icons,
	for example).

	Errors: BadWindow, BadValue

X_FetchName
	code		22
	windowId	Window

	Returns the name of a window.

	The reply:

	param.s[0]	number of characters

	The reply is followed by the specified number of characters of name,
	followed by 0 to 3 pad bytes to make the length a multiple of four.

	Errors: BadWindow

X_SetIconWindow
	code		23
	windowId	Window
	param.l[0]	icon Window or 0

	Sets/clears the icon window for a window.  The icon window must be a
	sibling of the specified window, both windows must be opaque, and
	neither can already be an icon window.

	An icon window should be used when the client wants to control the
	contents of the icon form.  A window manager should create an icon
	window automatically if the client doesn't provide one.  

	Errors: BadWindow, BadMatch

X_SetResizeHint
	code		24
	windowId	Window
	param.s[0]	base height (>= 0)
	param.s[1]	height increment (> 0)
	param.s[2]	base width (>= 0)
	param.s[3]	width increment (> 0)

	Defines the shape of a window.  The inside height of the window should
	be the base height plus some multiple of the height increment, and the
	inside width of the window should be the base width plus some multiple
	of the width increment.  These parameters are hints, in that
	X_ChangeWindow and X_ConfigureWindow do not check conformance.

	A newly created window has a base height and width of zero, and height
	and width increments of one.

	The base height and width must be non-negative, and the height and
	width increments must be positive.

	The resize hints are typically used by a window manager.

	Errors: BadWindow, BadValue

X_GetResizeHint
	code		25
	windowId	Window

	Returns the resize parameters.

	The reply:

	param.s[0]	minimum height
	param.s[1]	height increment
	param.s[2]	minimum width
	param.s[3]	width increment

	Errors: BadWindow

X_DefineCursor
	code		26
	windowId	Window
	param.l[0]	Cursor or 0

	If a cursor is specified, it will be used when the mouse is in the
	window.  If no cursor is specified, the parent's cursor will be used
	when the mouse is in the window.

	On the root window, with no cursor specified, the default cursor is
	restored.

	Errors: BadWindow, BadCursor

X_SelectInput
	code		27
	windowId	Window
	param.l[0]	event mask

	Defines which input events the window is interested in.  If a window is
	not interested in an event, it usually will propagate up to the closest
	ancestor that is interested.  The bits of the mask are:

	KeyPressed	 0x0001		keyboard key pressed
	KeyReleased	 0x0002		keyboard key released
	ButtonPressed	 0x0004		mouse button pressed
	ButtonReleased	 0x0008		mouse button released
	EnterWindow	 0x0010		mouse entering window
	LeaveWindow	 0x0020		mouse leaving window
	MouseMoved	 0x0040		mouse moves within window
	ExposeWindow	 0x0080		full window changed and/or exposed
	ExposeRegion	 0x0100		region of window exposed
	ExposeCopy	 0x0200		region exposed by X_CopyArea
	RightDownMotion	 0x0400		mouse moves with right button down
	MiddleDownMotion 0x0800		mouse moves with middle button down
	LeftDownMotion	 0x1000		mouse moves with left button down
	UnmapWindow	 0x2000		window is unmapped
	FocusChange	 0x4000		keyboard focus changed

	Selecting ExposeRegion also selects ExposeWindow.

	Details of each kind of event are given later.

	Overrides all previous selections on the same window by all clients.

	If a window has both ButtonPressed and ButtonReleased selected, then a
	ButtonPressed event in that window will automatically "grab" the mouse
	until all buttons are released, with events sent to windows as
	described for X_GrabMouse.

	Input selection on the root window should be reserved for a window
	manager.

	Errors: BadWindow

X_GrabMouse
	code		28
	windowId	Window
	param.l[0]	Cursor
	param.l[1]	event mask

	All future mouse events will only go to windows for which the grabbing
	client has issued X_SelectInput commands.  (The event mask temporarily
	overrides any X_SelectInput on the window.)  If the client has not
	issued an X_SelectInput command on the window where the event would
	normally be sent, then the event will be sent to the specified window,
	provided the event is specified in the mask and is not EnterWindow or
	LeaveWindow.  Only the bits ButtonPressed, ButtonReleased, EnterWindow,
	LeaveWindow, MouseMoved, LeftDownMotion, MiddleDownMotion, and
	RightDownMotion are useful in the mask.  The specified cursor will be
	used regardless of what window the mouse is in.

	This request will fail if someone else has already grabbed the mouse
	and has not released it; the request overrides any other grab in
	progress for this client.

	If the request is successful there is a reply, but it contains no
	information.

	Errors: BadWindow, BadCursor, BadGrab

X_GrabButton
	code		29
	mask		button mask
	windowId	Window
	param.l[0]	Cursor
	param.l[1]	event mask

	The button mask must have exactly one of LeftMask, MiddleMask, or
	RightMask set, and may have some combination of ControlMask, MetaMask,
	ShiftMask, and ShiftLockMask set.  If the specified button is pressed
	when exactly the specified keys are down, this and all future mouse
	events are grabbed until all buttons are released, with events sent to
	windows as described for X_GrabMouse.  During the grab, the specified
	cursor will be used regardless of what window the mouse is in.

	This request will fail if some other client has already grabbed the
	same button/key combination and has not released it.

	If the request is successful there is a reply, but it contains no
	information.

	Errors: BadWindow, BadCursor, BadValue, BadGrab

X_QueryMouse
	code		30
	windowId	Window

	Returns the current mouse coordinates and the state of various keys
	and buttons.

	The reply:

	param.l[0]	Window
	param.s[2]	x coord
	param.s[3]	y coord
	param.s[4]	key and button state

	The coordinates of the mouse relative to window are given, even if the
	mouse is outside the window.  If the mouse is also in a mapped child
	window, the child is returned, otherwise the return window is 0.

	The high bits of the state parameter are the same as for the event
	detail in keyboard and mouse events, and are defined further below
	in the discussion of input events.

	Errors: BadWindow

X_InterpretLocator
	code		31
	windowId	Window
	param.l[0]	Locator

	Interprets the coordinate with respect to the window.

	The reply:

	param.l[0]	Window
	param.s[2]	x coord
	param.s[3]	y coord

	The coordinates of the locator relative to the window are given, even
	if the locator is outside the window.  If the locator is also in a
	mapped child window, the child is returned, otherwise the return window
	is 0.

	Errors: BadWindow

X_WarpMouse
	code		32
	windowId	destination Window
	param.s[0]	destination x coord
	param.s[1]	destination y coord
	param.l[1]	source Window
	param.s[4]	source height
	param.s[5]	source width
	param.s[6]	source left coord
	param.s[7]	source top coord

	Move the mouse to the destination position relative to the origin of
	the destination window, but only if the mouse is currently in a visible
	portion of the specified region of the source window.

	If the source height is zero, the current height of the source window
	minus the source top coord is used.  If the source width is zero, the
	current width of the source window minus the source left coord is used.

	Errors: BadWindow

X_FocusKeyboard
	code		33
	func		0 (for future expansion)
	windowId	Window

	The specified window becomes the keyboard "focus" window.  If the
	window that would normally receive a KeyPressed or KeyReleased event is
	not (a descendant of) the focus window, then the event will be directed
	at the focus window instead.

	Generates a FocusChange event with detail LeaveWindow on the current
	focus window, and a FocusChange event with detail EnterWindow on the
	new focus window.

	The default focus window is the root window.  If the focus window is
	destroyed, its parent window becomes the focus window.

	Errors: BadWindow

X_CircWindowDown
	code		34
	windowId	Window

	Lower the highest mapped child of this window that (partially) obscures
	another child.  Repeated executions lead to round robin lowering.

	Generates exposure events on formerly obscured opaque windows.

	Errors: BadWindow

X_QueryTree
	code		35
	windowId	Window

	Returns the parent and child windows of the specified window.

	The reply:

	param.l[0]	parent Window (or 0 if none)
	param.l[1]	number of child windows

	The reply is followed by the specified number of child Window ids, each
	Window id being four bytes long.  The children are listed in current
	stacking order, from bottom-most (first) to top-most (last).

	Errors: BadWindow


X_Clear
	code		40
	windowId	Window

	Clear the window and repaint it with the background.  The tiling origin
	is controlled by the tilemode.

	A transparent window inherits its parent's background for this
	operation.

	Errors: BadWindow

X_PixFill
	code		41
	func		display function (0-15)
	mask		plane mask
	windowId	Window
	param.s[0]	destination height
	param.s[1]	destination width
	param.s[2]	destination left coord
	param.s[3]	destination top coord
	param.u[4]	source pixel
	param.l[3]	mask Bitmap or 0

	Performs a function in a region of the window.  The source pixel
	defines the value of the source bit for each plane, and the plane mask
	defines which destination bit planes are affected.  The display
	function is computed on each bit plane.  If no mask bitmap is
	specified, the entire destination is affected.  If a mask bitmap is
	specified, it defines the shape of the source and which pixels of the
	destination will be affected.

	Errors: BadWindow, BadValue, BadBitmap

X_TileFill
	code		42
	func		display function (0-15)
	mask		plane mask
	windowId	Window
	param.s[0]	destination height
	param.s[1]	destination width
	param.s[2]	destination left coord
	param.s[3]	destination top coord
	param.l[2]	tile Pixmap
	param.l[3]	mask Bitmap or 0

	Performs a function in a region of the window using a repeating pattern
	defined by the tile pixmap.  The tiling origin is controlled by the
	window's tilemode.  The plane mask defines which destination bit planes
	are affected.  The display function is computed on each bit plane.  If
	no mask bitmap is specified, the entire destination is affected.  If a
	mask bitmap is specified, it defines which pixels of the destination
	will be affected, and must be the same height and width as the
	destination.

	Errors: BadWindow, BadValue, BadPixmap, BadTile, BadBitmap, BadMatch

X_PixmapPut
	code		43
	func		display function (0-15)
	mask		plane mask
	windowId	Window
	param.s[0]	source height
	param.s[1]	source width
	param.s[2]	source left coord
	param.s[3]	source top coord
	param.l[2]	source Pixmap
	param.s[6]	destination left coord
	param.s[7]	destination top coord

	Performs a function in a region of the window using a region of a
	pixmap.  The source height, width, and coordinates specify the region
	of the source pixmap to be used.  The plane mask defines which
	destination bit planes are affected.  The display function is computed
	on each bit plane.

	Errors: BadWindow, BadValue, BadPixmap

X_PixmapBitsPut
	code		44
	func		display function (0-15)
	mask		plane mask
	windowId	Window
	param.s[0]	source height (> 0)
	param.s[1]	source width (> 0)
	param.s[2]	destination left coord
	param.s[3]	destination top coord
	param.s[4]	0: XYFormat
			1: ZFormat
	param.l[3]	mask Bitmap or 0

	Performs a function in a region of the window using a pixmap.  The
	plane mask defines which destination bit planes are affected.  The
	display function is computed on each bit plane.  If a mask bitmap is
	specified, it defines which pixels of the destination will be affected,
	and must be the same height and width as the source.


	The request must be followed by the data bytes of the source pixmap in
	the specified format, followed by 0 to 3 pad bytes to make the length
	a multiple of four.

	Errors: BadWindow, BadValue, BadBitmap, BadMatch

X_BitmapBitsPut
	code		45
	func		display function (0-15)
	mask		plane mask
	windowId	Window
	param.s[0]	source height (> 0)
	param.s[1]	source width (> 0)
	param.s[2]	destination left coord
	param.s[3]	destination top coord
	param.u[4]	foreground pixel
	param.u[5]	background pixel
	param.l[3]	mask Bitmap or 0

	Performs a function in a region of the window using a pixmap defined by
	a bitmap and a pair of source pixels.  The foreground pixel defines the
	source for the one bits in the bitmap, and the background pixel defines
	the source for the zero bits.  The plane mask defines which destination
	bit planes are affected.  The display function is computed on each bit
	plane.  If a mask bitmap is specified, it defines which pixels of the
	destination will be affected, and must be the same height and width as
	the source.


	The request must be followed by the data bytes of the source bitmap in
	bitmap format, followed by 0 or 2 pad bytes to make the length a
	multiple of four.

	Errors: BadWindow, BadValue, BadBitmap, BadMatch

X_CopyArea
	code		46
	func		display function (0-15)
	mask		plane mask
	windowId	Window
	param.s[0]	source height
	param.s[1]	source width
	param.s[2]	source left coord
	param.s[3]	source top coord
	param.s[6]	destination left coord
	param.s[7]	destination top coord

	Copies one region of the window to another region in the same window.
	The plane mask defines which destination bit planes are affected.  The
	display function is computed on each bit plane.

	If parts of the source are obscured, the corresponding parts of the
	destination are filled with the window's background.  If ExposeCopy has
	been selected, ExposeRegion events will be generated for those parts of
	the destination, and then an ExposeCopy event will be generated.  All
	of these events are guaranteed to be together in the stream, with no
	intervening events.

	Errors: BadWindow, BadValue

X_Text
	code		47
	func		display function (0-15)
	mask		plane mask
	windowId	Window
	param.s[0]	destination left coord
	param.s[1]	destination top coord
	param.l[1]	Font
	param.u[4]	foreground pixel
	param.u[5]	background pixel
 	param.s[6]	number of characters (>= 0)
	param.b[14]	inter-character pad
	param.b[15]	space character pad

	Draws text using the specified function.  The coordinates are for the
	upper left of the first character.  The foreground pixel defines the
	source for the one bits in the font character bitmaps, and the
	background pixel defines the source for the zero bits.  The plane mask
	defines which destination bit planes are affected.  The display
	function is computed on each bit plane.  The inter-character pad
	specifies the number of pixels to skip after each character before
	printing the next character.  The space character pad specifies the
	number of additional pixels to skip after each space character before
	printing the next character.  The skipped pixels are not considered
	part of the source or destination, and are not altered.

	The request must be followed by the specified number of characters,
	followed by 0 to 3 pad bytes to make the length a multiple of four.

	Errors: BadWindow, BadValue, BadFont

X_TextMask
	code		48
	func		display function (0-15)
	mask		plane mask
	windowId	Window
	param.s[0]	destination left coord
	param.s[1]	destination top coord
	param.l[1]	Font
	param.u[4]	source pixel
 	param.s[6]	number of characters (>= 0)
	param.b[14]	inter-character pad
	param.b[15]	space character pad

	Like X_Text, but the source pixel defines the value of the source bit
	for each plane, and the font character bitmaps are used as masks to
	define which pixels of the destination are affected.

	The request must be followed by the specified number of characters,
	followed by 0 to 3 pad bytes to make the length a multiple of four.

	Errors: BadWindow, BadValue, BadFont

X_Line
	code		49
	func		display function (0-15)
	mask		plane mask
	windowId	Window
	param.s[0]	x1 coord
	param.s[1]	y1 coord
	param.s[2]	x2 coord
	param.s[3]	y2 coord
	param.u[4]	source pixel
	param.b[10]	brush height (> 0)
	param.b[11]	brush width (> 0)

	This request is the same as a DrawSolidLine X_Draw request with the two
	vertexes (x1, y1, VertexDontDraw) and (x2, y2, VertexDrawLastPoint).

	Errors: BadWindow, BadValue

X_Draw
	code		50
	func		display function (0-15)
	mask		plane mask
	windowId	Window
	param.s[0]	number of vertexes (>= 0)
	param.u[1]	source pixel
	param.b[4]	brush height (> 0)
	param.b[5]	brush width (> 0)
	param.s[3]	0: DrawSolidLine
			1: DrawDashedLine
			2: DrawPatternedLine
	param.u[4]	alternate source pixel (for patterned line)
	param.s[5]	pattern string (for dashed or patterned line)
	param.s[6]	pattern length (for dashed or patterned line) (1-16)
	param.s[7]	pattern multiplier (for dashed or patterned line) (> 0)

	Draws arbitrary polygons/curves using the specified function and brush
	rectangle.  The area covered should be that obtained by laying down the
	brush rectangle at every point along the path, with the upper left
	corner following the path.  Each pixel in that area may be processed
	just once, or the brush may be repainted for each point along the path.
	The plane mask defines which destination bit planes are affected.  The
	display function is computed on each bit plane.  For a solid line, the
	source pixel defines the value of the source bit for each plane.  For
	a dashed or patterned line, the pattern string specifies up to 16 bits
	of pattern; the pattern length specifies the number of bits.  The
	pattern multiplier specifies the number of times each bit in the string
	should be repeated before moving to the next bit.  The bits are used
	least significant first, wrapping as needed.  For a dashed line, the
	destination is only updated when the pattern bit is 1.  For a patterned
	line, the alternate source pixel is used when the pattern bit is 0.

	The request must be followed by the specified number of vertexes,
	followed by 0 or 2 pad bytes to make the length a multiple of four.
	The C definition of a vertex is:

	typedef struct _Vertex {
		short x, y;
		unsigned short flags;
	} Vertex;

	The flags are as follows:

	VertexRelative		0x0001		else absolute
	VertexDontDraw		0x0002		else draw
	VertexCurved		0x0004		else straight
	VertexStartClosed	0x0008		else not
	VertexEndClosed		0x0010		else not
	VertexDrawLastPoint	0x0020		else don't

	A relative vertex is expressed in terms of offsets from the previous
	vertex, an absolute vertex has offsets from the origin of the window.
	The first vertex is never relative.  VertexDontDraw and VertexCurved
	control drawing from the previous vertex to the current vertex.  It
	can be useful to combine VertexDontDraw and VertexCurved to define the
	shape of the displayed portion of the curve.  VertexDontDraw can also
	be used to combine multiple draws in one request.  VertexStartClosed
	should be set in the first vertex of a closed curve, VertexEndClosed in
	the last; the two should specify the same point.  In drawing from the
	previous vertex to the current vertex, the current vertex point is not
	drawn unless VertexDrawLastPoint is set.

	Errors: BadWindow, BadValue

X_DrawFilled
	code		51
	func		display function (0-15)
	mask		plane mask
	windowId	Window
	param.s[0]	number of vertexes (>= 0)
	param.u[1]	source pixel
	param.l[1]	tile Pixmap or 0

	Draws arbitrary filled polygons/curves using the specified function
	tiling pixmap or source pixel.  If a tile is specified, the tiling
	origin is controlled by the window's tilemode.  If no tile is given,
	the source pixel is used instead.  The plane mask defines which
	destination planes are affected.

	The request must be followed by the specified number of vertexes,
	followed by 0 or 2 pad bytes to make the length a multiple of four.

	The vertex list should only consist of one or more closed regions.
	A point is defined to be inside a region if an infinite ray with the
	point as an origin crosses the path of the region an odd number of
	times.

	Errors: BadWindow, BadValue, BadPixmap, BadTile

X_PixmapSave
	code		52
	windowId	Window
	param.s[0]	height (> 0)
	param.s[1]	width (> 0)
	param.s[2]	left coord
	param.s[3]	top coord

	Creates a pixmap from the given portion of the window.  The pixmap will
	contain a direct image of that portion of the screen, including any
	visible portions of subwindows or overlapping windows.

	The window must be mapped, and it must be the case that, if there were
	no subwindows or overlapping windows, the specified portion of the
	window would be fully visible on the screen.

	The reply:

	param.l[0]	Pixmap
	
	Errors: BadWindow, BadValue, BadAlloc

X_PixmapGet
	code		53
	func		0: XYFormat
			1: ZFormat
	windowId	Window
	param.s[0]	height (> 0)
	param.s[1]	width (> 0)
	param.s[2]	left coord
	param.s[3]	top coord

	Returns the contents of the given portion of the window in the given
	pixmap format.  The pixmap will contain a direct image of that portion
	of the screen, including any visible portions of subwindows or
	overlapping windows.

	The window must be mapped, and it must be the case that, if there were
	no subwindows or overlapping windows, the specified portion of the
	window would be fully visible on the screen.

	The reply:

	param.l[0]	number of bytes
	
	The reply is followed by the specified number of bytes of pixmap data,
	followed by 0 to 3 pad bytes to make the length a multiple of four.

	Errors: BadWindow, BadValue

X_StippleFill
	code		54
	func		display function (0-15)
	mask		plane mask
	windowId	Window
	param.s[0]	destination height
	param.s[1]	destination width
	param.s[2]	destination left coord
	param.s[3]	destination top coord
	param.u[4]	source pixel
	param.l[3]	stipple Bitmap

	Performs a function a a region of the window using a repeating pattern
	defined by the stipple bitmap.  The tiling origin is controlled by the
	window's tilemode.  The plane mask defines which destination bit planes
	are affected. The display function is computed on each bit plane.
	The destination pixels written are those corresponding to the 1 values
	in the pattern generated from the stipple bitmap.

	Errors: BadWindow, BadValue, BadTile, BadBitmap

X_SetUp
	code		80

	Returns the root window and device information.

	The reply:

	param.l[0]	root Window
	param.s[2]	protocol version number (10)
	param.s[3]	device identifier
	param.s[4]	number of bit planes
	param.u[5]	number of usable color map cells

	The currently defined devices are:
		XDEV_VS100	1
		XDEV_QVSS	2
		XDEV_QDSS	3

X_UngrabMouse
	code		81

	Releases hold of the mouse if it was grabbed via an X_GrabMouse.

X_UngrabButton
	code		82
	mask		button mask

	Releases hold of the button/key combination if it was grabbed.  The
	button mask must have exactly one of LeftMask, MiddleMask, or RightMask
	set, and may have some combination of ControlMask, MetaMask, ShiftMask,
	and ShiftLockMask set.

	Errors: BadValue

X_GetColor
	code		83
	param.u[0]	red value
	param.u[1]	green value
	param.u[2]	blue value

	Determines the closest color provided by the hardware, and returns a
	pixel value representing that color.  The corresponding color map cell
	is read-only.

	Read-only color map cells are shared among clients, so this request may
	simply reference count an existing cell.

	The reply:

	param.u[0]	pixel

	Errors: BadAlloc

X_GetColorCells
	code		84
	func		1 if planes must be contiguous, 0 otherwise
	param.s[0]	number of colors (>= 0)
	param.s[1]	number of planes (>= 0)

	Allocates N * 2^P color map cells, where N is the number of colors and
	P is the number of planes specified.

	The reply:

	param.u[0]	plane mask

	The bits in the plane mask will be contiguous if requested.  The reply
	is followed by 2 * N bytes of data, where N is the number of colors
	specified, followed by 0 or 2 pad bytes to make the length a multiple
	of four.  Each 16-bit word represents the pixel value of one of the
	color cells.  Additional pixel values are obtained by oring in all
	possible combinations of one bits from the plane mask.  The initial
	colors for all of these cells is undefined.

	If zero colors are requested, then the request allocates all cells with
	a pixel value having at least one non-zero bit in the plane mask.  At
	most one such request will succeed.

	Errors: BadValue, BadAlloc

X_FreeColors
	code		85
	mask		plane mask
	param.s[0]	number of colors (>= 0)

	Frees several colors or color map cells.  Further use of the given
	pixel values will result in undefined colors.

	The request must be followed by the specified number of 16-bit pixel
	values, followed by 0 or 2 pad bytes to make the length a multiple of
	four.  Additional pixel values are obtained by oring in all possible
	combinations of one bits from the plane mask.

	Errors: BadValue, BadAccess

X_StoreColors
	code		86
	param.s[0]	number of colors (>= 0)

	Change the colors of several pixels to the closest available hardware
	colors.

	The request must be followed by the specified number of color
	definitions.  The C definition is:

	typedef struct _ColorDef {
		unsigned short pixel;
		unsigned short red, green, blue;
	} ColorDef;

	Errors: BadValue, BadAccess

X_QueryColor
	code		87
	param.u[0]	pixel

	Returns the color values for a pixel.

	The reply:

	param.u[0]	red value
	param.u[1]	green value
	param.u[2]	blue value

	Errors: BadValue

X_GetFont
	code		88
	param.s[0]	length of name in chars (> 0)

	Loads a font.  This request must be followed by the characters of the
	font name, followed by 0 to 3 pad bytes to make the length a multiple
	of four.  Case is significant.

	Fonts are shared among clients, so this request may simply reference
	count an existing font.

	The reply:

	param.l[0]	Font

	Errors: BadValue, BadFont, BadAlloc

X_FreeFont
	code		89
	param.l[0]	Font

	Indicates that the font is no longer needed.  The font should never
	again be referenced.

	Errors: BadFont

X_QueryFont
	code		90
	param.l[0]	Font

	Returns information about a font.

	The reply:

	param.s[0]	height
	param.s[1]	"average" width
	param.s[2]	first character
	param.s[3]	last character
	param.s[4]	baseline
	param.s[5]	1 if fixed width, 0 if variable width

	The baseline specifies where in pixels from the bottom of the font the
	characters without descenders begin.

	A font is fixed width if all characters in the given range are the same
	width.

	Fonts will get more complicated in a future version.

	Errors: BadFont

X_CharWidths
	code		91
	param.l[0]	Font
	param.s[2]	number of characters (>= 0)

	Returns the width in pixels of each character.  The request must be
	followed by the specified number of characters, followed by 0 to 3 pad
	bytes to make the length a multiple of four.

	The reply:

	param.l[0]	number of bytes

	The reply is followed by the specified number of bytes of data,
	followed by 0 or 2 pad bytes to make the length a multiple of four.
	Each 16-bit word of data contains the width of a character.

	Errors: BadFont, BadValue

X_StringWidth
	code		92
	param.l[0]	Font
	param.s[2]	number of characters (>= 0)

	Returns the width in pixels of a string in a font.

	The request must be followed by the specified number of characters,
	followed by 0 to 3 pad bytes to make the length a multiple of four.

	The reply:

	param.s[0]	width in pixels

	Errors: BadFont, BadValue

X_FontWidths
	code		93
	param.l[0]	Font

	Returns the widths in pixels of all characters in a font.

	The reply:

	param.l[0]	number of bytes

	The reply is followed by the specified number of bytes of data,
	followed by 0 or 2 pad bytes to make the length a multiple of four.
	Each 16-bit word of data contains the width of a character.  The widths
	are for the range of characters given by X_QueryFont.

	Errors: BadFont

X_StoreBitmap
	code		94
	param.s[0]	height (> 0)
	param.s[1]	width (> 0)

	Creates a bitmap.

	The request must be followed by the correct number of bytes of data in
	bitmap format, followed by 0 or 2 pad bytes to make the length a
	multiple of four.

	The reply:

	param.l[0]	Bitmap

	Errors: BadValue, BadAlloc

X_FreeBitmap
	code		95
	param.l[0]	Bitmap

	Frees the storage consumed by the bitmap.  The bitmap should never be
	referenced again.

	Errors: BadBitmap

X_CharBitmap
	code		96
	param.l[0]	Font
	param.s[2]	character
	
	Copies a character bitmap from a font.

	The font can be freed immediately if no further explicit references to
	it are to be made.

	The reply:

	param.l[0]	Bitmap

	Errors: BadFont, BadValue, BadAlloc

X_StorePixmap
	code		97
	func		0: XYFormat
			1: ZFormat
	param.s[0]	height (> 0)
	param.s[1]	width (> 0)

	Creates a pixmap.

	The request must be followed by the correct number of bytes of data the
	specified format, followed by 0 to 3 pad bytes to make the length a
	multiple of four.

	The reply:

	param.l[0]	Pixmap

	Errors: BadValue, BadAlloc

X_FreePixmap
	code		98
	param.l[0]	Pixmap

	Frees the storage consumed by the pixmap.  The pixmap should never be
	referenced again.

	Errors: BadPixmap

X_MakePixmap
	code		99
	param.l[0]	Bitmap or 0
	param.u[2]	foreground pixel
	param.u[3]	background pixel

	Creates a pixmap from a bitmap.  The foreground pixel is used for the
	one bits in the bitmap, and the background pixel is used for the zero
	bits.  If no bitmap is given, a bitmap of all one bits suitable for use
	as a tiling pixmap is used.

	The bitmap can be freed immediately if no further explicit references
	to it are to be made.

	The reply:

	param.l[0]	Pixmap

	Errors: BadBitmap, BadValue, BadAlloc

X_QueryShape
	code		100
	func		0: CursorShape
			1: TileShape
			2: BrushShape
	param.s[0]	height (> 0)
	param.s[1]	width (> 0)

	Given a rectangular shape, returns the "closest" shape actually
	supported by the display for a given purpose.  For a cursor shape,
	returns a Bitmap shape acceptable for X_StoreCursor.  For a tile shape,
	returns a Pixmap shape acceptable for tiling.  For a brush shape,
	returns a shape acceptable for X_Line and X_Draw.

	The reply:

	param.s[0]	height
	param.s[1]	width

	Errors: BadValue

X_StoreCursor
	code		101
	func		display function (0-15)
	param.l[0]	cursor Bitmap
	param.u[2]	foreground pixel
	param.u[3]	background pixel
	param.l[2]	mask Bitmap or 0
	param.s[6]	x offset
	param.s[7]	y offset

	Defines a mouse cursor.  The foreground pixel is used for the one bits
	in the cursor bitmap, and the background pixel is used for the zero
	bits.  The mask bitmap defines the shape of the cursor; that is, the
	one bits in the mask define which cursor pixels will be displayed.  If
	no mask is given, all pixels of the cursor are displayed.  The mask
	bitmap, if present, must be the same size as the cursor bitmap.  The
	offsets define the point that actually corresponds to the mouse
	position; this must be a point in the cursor bitmap.

	The components of the cursor may be transformed arbitrarily to meet
	hardware limitations.

	The bitmaps can be freed immediately if no further explicit references
	to them are to be made.

	The reply:

	param.l[0]	Cursor

	Errors: BadValue, BadBitmap, BadMatch, BadAlloc

X_FreeCursor
	code		102
	param.l[0]	Cursor

	Frees the storage consumed by the cursor.  The cursor should never be
	referenced again.

	Errors: BadCursor

X_MouseControl
	code		103
	param.s[0]	acceleration (>= 1)
	param.s[1]	threshold (>= 0)

	Defines how the mouse moves.  The acceleration is a multiplier for
	movement.  E.g., specifying 3 means the cursor moves three times as
	fast as the mouse.  Acceleration only takes effect if the mouse moves
	more than threshold pixels at once, and only applies to the amount
	beyond the threshold.

	Errors: BadValue

X_FeepControl
	code		104
	func		volume (0-7)

	Defines the base volume for X_Feep requests.  The volume is in the
	range 0 to 7, with 7 the loudest.

	Errors: BadValue

X_Feep
	code		105
	param.s[0]	relative volume (-7 to 7)

	Cause an audible bell.  The volume is added to the base volume defined
	by the X_FeepControl request, the sum limited to the range 0 to 7.

	Errors: BadValue

X_ShiftLock
	code		106
	func		0: LockUpDownMode
			1: LockToggleMode

	Sets the mode of the Shift LOCK key on the keyboard.  When the keyboard
	is in LockUpDownMode, KeyPressed and KeyReleased events are sent as for
	any other key, and the ShiftLockMask sent in events gives the current
	state of the key.  In LockToggleMode, KeyPressed and KeyReleased events
	are never sent for the LOCK key, and the state of the ShiftLockMask
	sent in events is toggled on every press of the LOCK key.

	The key is initially in LockToggleMode.

	Errors: BadValue

X_KeyClick
	code		107
	func		volume (0-8)

	Turns keyboard key click off (volume 0), or turns it on and sets the
	volume, with 8 the loudest.

	Errors: BadValue

X_AutoRepeat
	code		108
	func		0 for off, 1 for on

	Turns keyboard autorepeat on or off.

	Errors: BadValue

X_ScreenSaver
	code		109
	func		0 for video off, 1 for video on
	param.s[0]	screen saver timeout in minutes (> 0)
	param.s[1]	pattern change timeout interval in minutes (> 0)

	If the server remains idle for the specified number of minutes, screen
	saver is enabled.  If video off is specified, and the hardware supports
	video blanking, the screen will simply go blank.  Otherwise, the
	screen will be tiled with the root window background tile, randomly
	re-origined at the specified timeout interval.  The screen state will
	be restored when the next request or input event occurs.

	Errors: BadValue

X_StoreBytes
	code		110
	func		cut buffer (0-7)
	param.s[0]	number of bytes (>= 0)

	Stores an arbitrary string of bytes one of eight "cut buffers".  These
	bytes may be retrieved with the X_FetchBytes request.

	The previous contents of the cut buffer are lost.

	The request must be followed by the specified number of bytes of data,
	followed by 0 to 3 pad bytes to make the length a multiple of four.

	Errors: BadValue

X_FetchBytes
	code		111
	func		cut buffer (0-7)

	Retrieves the contents of the specified cut buffer.

	The reply:

	param.s[0]	number of bytes

	The reply is followed by the specified number of bytes of data,
	followed by 0 to 3 pad bytes to make the length a multiple of four.

	Errors: BadValue

X_RotateCuts
	code		112
	func		rotate count (0-7)

	Rotates the cut buffers by N.  Buffer 0 becomes buffer N, buffer 1
	becomes N+1 mod 8, and so on.

	Errors: BadValue

X_AddHost
	code		113
	func		address family
	param.l[0-?]	host address

	Add the specified host to the list of hosts allowed to open
	connections.

	The currently recognized address families are
		XAF_INET		2
		XAF_DECnet		12
	In Unix term, the host address for XAF_INET is "struct in_addr",
	and for XAF_DECnet is "struct dn_naddr".

	The client must reside on the same host as the window system.

	Under Unix, the initial set of hosts consists of the host the window
	system is running on, plus those hosts listed in /etc/X?.hosts, where ?
	is the number of the display.  This file should consist of host names
	separated by newlines.  DECnet host names must have a trailing "::".

	Errors: BadValue, BadAccess

X_RemoveHost
	code		114
	func		address family
	param.l[0-?]	host address

	Remove the specified host from the list of hosts allowed to open
	connections.

	The address family and host address are as for X_AddHost.

	The client must reside on the same host as the window system.

	Errors: BadValue, BadAccess

X_GetHosts
	code		115
	func		address family

	Returns the current list of hosts allowed to open connections.

	The reply:

	param.l[0]	number of bytes

	The reply is followed by the specified number of bytes of data,
	containing a list of host addresses.  The size of each host address
	is determined by the address family, as for X_AddHost.

	Errors: BadValue

X_GrabServer
	code		116

	Disables processing of requests and close-downs on all other
	connections (than the one this request arrived on).

X_UngrabServer
	code		117

	Restarts processing of requests and close-downs on other connections.

X_LookupColor
	code		118
	param.s[0]	length of name in characters (>= 0)

	Returns the color values for a given color name.  The name is looked
	up in a standard color database.  This request must be followed by the
	characters of the color name, followed by 0 to 3 pad bytes to make the
	length a multiple of four.  Case is significant.

	The reply:

	param.u[0]	exact red value
	param.u[1]	exact green value
	param.u[2]	exact blue value
	param.u[3]	closest hardware red value
	param.u[4]	closest hardware green value
	param.u[5]	closest hardware blue value

	Errors: BadValue, BadColor


Input events:

Selecting MouseMoved will result in events independent of the state of the
mouse buttons.  By selecting some subset of (LeftDownMotion, MiddleDownMotion,
RightDownMotion) instead, MouseMoved events will only be generated when one or
more of the specified buttons is depressed.

KeyPressed, KeyReleased, ButtonPressed, ButtonReleased, and MouseMoved events
are usually sent to the smallest window enclosing the mouse that has selected
such events.  For KeyPressed and KeyReleased events, if this window is not in
the keyboard focus hierarchy, the events will be sent to the focus window
instead.

KeyPressed, KeyReleased, ButtonPressed, ButtonReleased, EnterWindow,
LeaveWindow, and MouseMoved events have the following structure:

	code		kind of event (KeyPressed, etc.)
	param.l[0]	event Window
	param.s[2]	time in 10 millisecond ticks (Key and Button only)
	param.s[3]	event detail
	param.s[4]	mouse x coord within event window
	param.s[5]	mouse y coord within event window
	param.l[3]	sub Window
	param.l[4]	Locator

The coordinates of the mouse relative to the event window are reported, even if
the mouse is not in the window (because of grabbing or keyboard focusing).  If
the mouse is also in a (direct) child of the event window, the subwindow is set
to that child, otherwise the subwindow is 0.  The locator defines the mouse
coordinates in absolute terms.

The time value is present only for KeyPressed, KeyReleased, ButtonPressed, and
ButtonReleased events.  Note that there are only 16 bits of time (which should
be treated as unsigned), which wraps after approximately 11 minutes, so only
time differences between clustered events is interesting.

For all seven event types, the high bits of the detail encode the state of
various keys and buttons just before the event:

	ControlMask	0x4000			Control key
	MetaMask	0x2000			Meta (Symbol) key
	ShiftMask	0x1000			Shift key
	ShiftLockMask	0x0800			ShiftLock key
	LeftMask	0x0400			Left button
	MiddleMask	0x0200			Middle button
	RightMask	0x0100			Right button

For KeyPressed and KeyReleased, the low byte of the detail gives the key.  This
is not an ASCII character, but the code transmitted by the LK201 keyboard.

For ButtonPressed and ButtonReleased, the low byte of the detail is one of:

	RightButton	0
	MiddleButton	1
	LeftButton	2

For EnterWindow and LeaveWindow, the low byte of the detail is either zero or
one of:
	IntoOrFromSubwindow	1
	VirtualCrossing		2

EnterWindow and LeaveWindow events are generated as follows:

    When the mouse moves from window A to window B, and B is an ancestor of A:
	A will get a LeaveWindow with detail 0
	windows between A and B exclusive that have LeaveWindow selected
		will get a LeaveWindow with detail 2
	B will get an EnterWindow with detail 1

    When the mouse moves from window A to window B, and B is a descendant of A:
	A will get a LeaveWindow with detail 1
	windows between A and B exclusive that have EnterWindow selected
		will get an EnterWindow with detail 2
	B will get an EnterWindow with detail 0

    When the mouse moves from window A to window B, with window C being their
    least common ancestor:
	A will get a LeaveWindow with detail 0
	windows between A and C exclusive that have LeaveWindow selected
		will get a LeaveWindow with detail 2
	windows between C and B exclusive that have EnterWindow selected
		will get an EnterWindow with detail 2
	B will get an EnterWindow with detail 0

    At the start of a mouse grab, either automatically from a button press,
    or from an X_GrabMouse or X_GrabButton, with the mouse in window A, and
    with window B being the smallest window enclosing the mouse that has had
    an X_SelectInput issued on it by some client:
	A will get a LeaveWindow with detail 0 if the grabbing client has
		not issued an X_SelectInput command on B
	ancestors of A (not including the root) will get a LeaveWindow with
		detail 2 if the grabbing client has not issued an X_SelectInput
		on the window and the window has LeaveWindow selected.

    At the end of a mouse grab, with the mouse in window A, and with window B
    being the smallest window enclosing the mouse that has had an X_SelectInput
    issued on it by some client:
	ancestors of A (not including the root) will get an EnterWindow with
		detail 2 if the grabbing client has not issued an X_SelectInput
		on the window and the window has EnterWindow selected.
	A will get an EnterWindow with detail 0 if the grabbing client has
		not issued an X_SelectInput command on B.

Note that EnterWindow and LeaveWindow events with detail 0 or 1 (but not 2)
will propagate to the smallest enclosing window that has actually selected the
event.

LeaveWindow events are not generated when windows are unmapped or destroyed.

UnmapWindow events occur whenever an X_UnmapWindow or X_UnmapSubwindows request
is executed on a mapped window.  The event structure is:

	code		UnmapWindow
	param.l[0]	event Window
	param.l[3]	sub Window

If a subwindow is given, it is the actual window on which the request was
issued (not the ancestor that is a direct child of the event window).

FocusChange events occur whenever the keyboard focus changes.  The event
structure is:

	code		FocusChange
	param.l[0]	event Window
	param.s[3]	EnterWindow or LeaveWindow
	param.l[3]	sub Window

If a subwindow is given, it is the actual window on which the request was
issued (not the ancestor that is a direct child of the event window).

For ExposeWindow and ExposeRegion events, the structure is as follows:

	code		ExposeWindow or ExposeRegion
	param.l[0]	event Window
	param.s[3]	detail (0 or ExposeCopy)
	param.s[4]	width of area
	param.s[5]	height of area
	param.l[3]	sub Window
	param.s[8]	top coord of area
	param.s[9]	left coord of area

Coordinates are relative to the inside of the exposed window.

ExposeWindow and ExposeRegion events are triggered as (parts of) windows become
exposed.  When an entire window becomes exposed (as when a window is mapped or
changes size), an ExposeWindow event is sent.  The width and height of the
entire window is given, and the coordinates are (0, 0).  When only parts of a
window become exposed (as when an obscuring window is moved), ExposeRegion
events are sent describing each newly exposed area.  However, if only
ExposeWindow has been selected, a single ExposeWindow will be sent instead.  If
the region exposure is the result of a CopyArea, then ExposeCopy will be set in
the detail word.  If the exposure is actually that of a descendant of the
window selecting the event, the subwindow is set to that descendant and the
coordinates are actually for the subwindow, otherwise the subwindow is 0.  For
a given window exposure or CopyArea, all resulting ExposeRegion events will be
sent contiguously, with no other events interspersed.

For ExposeCopy events, the structure is as follows:

	code		ExposeCopy
	param.l[0]	event Window
	param.l[3]	sub Window

If the CopyArea was done in a descendant of the window selecting the event, the
subwindow is set to that descendant, otherwise the subwindow is 0.
